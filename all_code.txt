// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:video_player_web/video_player_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  VideoPlayerPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}
import 'package:flutter/material.dart';
import 'package:promts_application_1/features/main/view/widgets/widget_main_screen.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Promts',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const WidgetMainScreen(),
    );
  }
}
// Минимальная модель, соответствующая элементам из "chats": [...]

class ChatShortDTO {
  final int id;
  final String chatName;
  final bool starredChat;
  final DateTime dateEdit;

  ChatShortDTO({
    required this.id,
    required this.chatName,
    required this.starredChat,
    required this.dateEdit,
  });

  factory ChatShortDTO.fromJson(Map<String, dynamic> json) {
    return ChatShortDTO(
      id: json['id'] as int,
      chatName: json['chatName'] as String? ?? 'Без названия',
      starredChat: json['starredChat'] as bool? ?? false,
      dateEdit: DateTime.parse(json['dateEdit'] as String),
    );
  }
}
import 'package:flutter/material.dart';

/// NavigationDrawer, который показывает список чатов пользователя.
class WidgetChats extends StatefulWidget {
  // Callback, который передает выбранное имя чата (или его id)
  final ValueChanged<String> onChatSelected;

  const WidgetChats({super.key, required this.onChatSelected});

  @override
  State<WidgetChats> createState() => _WidgetChatsState();
}

class _WidgetChatsState extends State<WidgetChats> {
  final TextEditingController _searchController = TextEditingController();

  // Список чатов для примера
  final List<String> _chats = [
    "Первый чат",
    "Второй чат",
    "Третий чат",
    "Четвёртый чат",
  ];

  // Результаты поиска
  List<String> _filteredChats = [];

  @override
  void initState() {
    super.initState();
    // Изначально показываем все чаты
    _filteredChats = List.from(_chats);
  }

  // Логика поиска
  void _searchChats() {
    final query = _searchController.text.toLowerCase().trim();
    setState(() {
      if (query.isEmpty) {
        _filteredChats = List.from(_chats);
      } else {
        _filteredChats = _chats.where((chat) {
          return chat.toLowerCase().contains(query);
        }).toList();
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        children: [
          // Заголовок (необязательно)
          const ListTile(
            title: Text(
              "Мои чаты",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          // Строка поиска
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Row(
              children: [
                // Поле ввода
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: const InputDecoration(
                      labelText: "Поиск чатов",
                      border: OutlineInputBorder(),
                    ),
                    onChanged: (value) {
                      _searchChats();
                    },
                  ),
                ),
                const SizedBox(width: 8),
                // Кнопка поиска
                IconButton(
                  icon: const Icon(Icons.search),
                  onPressed: _searchChats,
                ),
              ],
            ),
          ),
          // Список чатов
          Expanded(
            child: ListView.builder(
              itemCount: _filteredChats.length,
              itemBuilder: (context, index) {
                final chatName = _filteredChats[index];
                return ListTile(
                  title: Text(chatName),
                  onTap: () {
                    // Закрываем Drawer
                    Navigator.of(context).pop();
                    // Вызываем callback с именем выбранного чата
                    widget.onChatSelected(chatName);
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';

class WidgetChatCreateSettings extends StatefulWidget {
  final int chatId;              // ID чата
  final double temperature;      // Температура чата
  final String contextChat;      // Контекст (правила) чата
  final bool useMemory;          // Использовать ли память в чате?
  final bool updateMemory;       // Может ли чат изменять память пользователя?

  /// Колбэк, который вызывается при нажатии "Сохранить".
  /// Возвращает все обновлённые данные (в виде Map) в onSave().
  final ValueChanged<Map<String, dynamic>> onSave;

  const WidgetChatCreateSettings({
    super.key,
    required this.chatId,
    required this.temperature,
    required this.contextChat,
    required this.useMemory,
    required this.updateMemory,
    required this.onSave,
  });

  @override
  State<WidgetChatCreateSettings> createState() => _WidgetChatCreateSettingsState();
}

class _WidgetChatCreateSettingsState extends State<WidgetChatCreateSettings> {
  late double _temperature;
  late TextEditingController _contextController;
  late bool _useMemory;
  late bool _updateMemory;

  @override
  void initState() {
    super.initState();
    _temperature = widget.temperature;
    _contextController = TextEditingController(text: widget.contextChat);
    _useMemory = widget.useMemory;
    _updateMemory = widget.updateMemory;
  }

  @override
  void dispose() {
    _contextController.dispose();
    super.dispose();
  }

  void _handleSave() {
    // Собираем данные, которые надо сохранить
    final updatedData = {
      'chatId': widget.chatId,
      'temperature': _temperature,
      'contextChat': _contextController.text,
      'useMemory': _useMemory,
      'updateMemory': _updateMemory,
    };
    // Вызываем колбэк, передавая обновлённые данные
    widget.onSave(updatedData);
    // Закрываем диалог
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text("Создание чата"),
      content: SizedBox(
        width: 400,   // Зафиксированная ширина окна
        height: 350,  // Зафиксированная высота окна
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // (1) ID чата
            Row(
              children: [
                const Text("ID чата: "),
                Text(widget.chatId.toString()),
              ],
            ),
            const SizedBox(height: 8),

            // (2) Температура чата (пример с DropdownButton)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Температура чата:"),
                DropdownButton<double>(
                  value: _temperature,
                  items: [0.0, 0.5, 1.0, 1.5, 2.0].map((temp) {
                    return DropdownMenuItem<double>(
                      value: temp,
                      child: Text(temp.toString()),
                    );
                  }).toList(),
                  onChanged: (val) {
                    if (val != null) {
                      setState(() {
                        _temperature = val;
                      });
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // (3) Контекст чата (многострочное поле)
            
            TextField(
              controller: _contextController,
              decoration: const InputDecoration(
                labelText: "Контекст чата",
                border: OutlineInputBorder(),
              ),
              keyboardType: TextInputType.multiline,
              minLines: 3,
              maxLines: 5,
            ),
            const SizedBox(height: 8),

            // (4) Использовать ли память в данном чате?
            Row(
              children: [
                const Expanded(child: Text("Использовать ли память в чате?")),
                Switch(
                  value: _useMemory,
                  onChanged: (val) {
                    setState(() {
                      _useMemory = val;
                    });
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // (5) Может ли чат изменять память?
            Row(
              children: [
                const Expanded(child: Text("Может ли чат изменять память пользователя?")),
                Switch(
                  value: _updateMemory,
                  onChanged: (val) {
                    setState(() {
                      _updateMemory = val;
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text("Отмена"),
        ),
        ElevatedButton(
          onPressed: _handleSave,
          child: const Text("Сохранить"),
        ),
      ],
    );
  }
}
import 'package:flutter/material.dart';

/// Модель сообщения
class ChatMessage {
  final String text;
  final bool isUser; // true: сообщение пользователя, false: сообщение нейросети

  ChatMessage({required this.text, required this.isUser});
}

class WidgetChatPage extends StatefulWidget {
  const WidgetChatPage({super.key});

  @override
  _WidgetChatPageState createState() => _WidgetChatPageState();
}

class _WidgetChatPageState extends State<WidgetChatPage> {
  final List<ChatMessage> _messages = [
    ChatMessage(text: "Привет, я бот!", isUser: false),
    ChatMessage(text: "Здравствуйте!", isUser: true),
  ];
  final TextEditingController _messageController = TextEditingController();

  @override
  void dispose() {
    _messageController.dispose();
    super.dispose();
  }

  /// Отправка нового сообщения от пользователя
  void _sendMessage() {
    final text = _messageController.text.trim();
    if (text.isEmpty) return;

    setState(() {
      // Добавляем сообщение пользователя
      _messages.add(ChatMessage(text: text, isUser: true));
    });
    _messageController.clear();

    // Здесь можно добавить логику для получения ответа от нейросети (isUser: false)
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Список сообщений
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            itemCount: _messages.length,
            itemBuilder: (context, index) {
              final msg = _messages[index];
              return _buildMessageBubble(msg);
            },
          ),
        ),
        // Поле ввода сообщения + кнопка отправки
        Container(
          color: Colors.grey[200],
          padding: const EdgeInsets.all(8),
          child: Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _messageController,
                  decoration: const InputDecoration(
                    hintText: "Введите сообщение",
                    border: OutlineInputBorder(),
                  ),
                  minLines: 1,
                  maxLines: 5,
                ),
              ),
              const SizedBox(width: 8),
              IconButton(
                icon: const Icon(Icons.send),
                onPressed: _sendMessage,
              ),
            ],
          ),
        ),
      ],
    );
  }

  /// Создаёт «пузырь» сообщения.
  /// Если сообщение пользователя (isUser = true), выравниваем его справа, иначе — слева.
  Widget _buildMessageBubble(ChatMessage msg) {
    final alignment = msg.isUser ? Alignment.centerRight : Alignment.centerLeft;
    final bgColor = msg.isUser ? Colors.blue[100] : Colors.grey[300];

    return Align(
      alignment: alignment,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4),
        padding: const EdgeInsets.all(10),
        constraints: const BoxConstraints(maxWidth: 250),
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Text(msg.text),
      ),
    );
  }
}
import 'package:flutter/material.dart';

/// Виджет чат-ботов (endDrawer), в котором есть:
///  - Кнопка создания чат-бота (слева),
///  - Строка поиска и кнопка поиска,
///  - Список чат-ботов, каждый элемент имеет иконку "!" для просмотра инфо.
class WidgetChatBots extends StatefulWidget {
  const WidgetChatBots({super.key});

  @override
  State<WidgetChatBots> createState() => _WidgetChatBotsState();
}

class _WidgetChatBotsState extends State<WidgetChatBots> {
  final TextEditingController _searchController = TextEditingController();

  /// Пример данных о чат-ботах (в реальном приложении вы можете получать их с бэкенда).
  final List<Map<String, dynamic>> _allChatBots = [
    {
      "id": 1,
      "chatBotName": "Помощник по программированию",
      "chatBotDesc": "Помогает с вопросами по Python, Java и другим языкам.",
      "messagesToday": 123,
      "totalMessages": 1000,
      "isSelectedByRedact": true
    },
    {
      "id": 2,
      "chatBotName": "Финансовый советник",
      "chatBotDesc": "Помогает с вопросами по инвестициям и бюджету.",
      "messagesToday": 87,
      "totalMessages": 500,
      "isSelectedByRedact": false
    },
    {
      "id": 3,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 4,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 5,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 6,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 7,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 8,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 9,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 10,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 11,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 12,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
        {
      "id": 13,
      "chatBotName": "Новый помощник",
      "chatBotDesc": "Описание нового помощника.",
      "messagesToday": 0,
      "totalMessages": 0,
      "isSelectedByRedact": false
    },
  ];

  /// Список отфильтрованных чат-ботов (поиск).
  List<Map<String, dynamic>> _filteredChatBots = [];

  @override
  void initState() {
    super.initState();
    // Изначально показываем всех чат-ботов
    _filteredChatBots = List.from(_allChatBots);
  }

  /// Логика поиска чат-ботов
  void _searchChatBots() {
    final query = _searchController.text.trim().toLowerCase();
    setState(() {
      if (query.isEmpty) {
        _filteredChatBots = List.from(_allChatBots);
      } else {
        _filteredChatBots = _allChatBots.where((bot) {
          final name = bot["chatBotName"]?.toString().toLowerCase() ?? "";
          return name.contains(query);
        }).toList();
      }
    });
  }

  /// Создание нового чат-бота (пока просто пример)
  void _createChatBot() {
    // Закрываем Drawer
    Navigator.of(context).pop();
    // TODO: здесь логика для экрана создания чат-бота
    print("Открыть экран создания нового чат-бота");
  }

  /// Просмотр информации о чат-боте (иконка "!")
  void _showBotInfo(Map<String, dynamic> bot) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(bot["chatBotName"] ?? "Чат-бот"),
        content: Text(bot["chatBotDesc"] ?? "Без описания"),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text("Закрыть"),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        children: [
          // Заголовок (необязательно)
          const ListTile(
            title: Text(
              "Список чат-ботов",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          // Строка поиска + кнопка создания чат-бота + кнопка поиска
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Row(
              children: [
                // (5.3) Кнопка создания своего чат-бота (слева)
                ElevatedButton(
                  onPressed: _createChatBot,
                  child: const Text("Создать чат-бота"),
                ),
                const SizedBox(width: 8),
                // (5.1) Строка поиска чатов по названию
                Expanded(
                  child: TextField(
                    controller: _searchController,
                    decoration: const InputDecoration(
                      labelText: "Поиск чат-ботов",
                      border: OutlineInputBorder(),
                    ),
                    onChanged: (value) => _searchChatBots(),
                  ),
                ),
                const SizedBox(width: 8),
                // (5.1.1) Кнопка поиска
                IconButton(
                  icon: const Icon(Icons.search),
                  onPressed: _searchChatBots,
                ),
              ],
            ),
          ),
          // (5.2) Список чат-ботов
          Expanded(
            child: ListView.builder(
              itemCount: _filteredChatBots.length,
              itemBuilder: (context, index) {
                final bot = _filteredChatBots[index];
                return ListTile(
                  title: Text(bot["chatBotName"] ?? "Без названия"),
                  subtitle: Text(bot["chatBotDesc"] + "\nСегодня " + bot["messagesToday"].toString() +" сообщений" ?? "Без описания"),
                  // (5.2.1) Кнопка для просмотра информации о чат-боте (иконка "!")
                  trailing: IconButton(
                    icon: const Icon(Icons.info_outline),
                    onPressed: () => _showBotInfo(bot),
                  ),
                  onTap: () {
                    // Закрываем Drawer
                    Navigator.of(context).pop();
                    // TODO: логика открытия/использования выбранного чат-бота
                    print("Выбран чат-бот: ${bot["chatBotName"]}");
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:promts_application_1/features/user/view/widgets/widget_user_settings.dart';
import '../../../chatbot/view/widgets/widget_chat_bots.dart';

/// AppBar с кнопкой Promts и дополнительным callback для нее.
class WidgetAppBar extends StatelessWidget implements PreferredSizeWidget {
  final VoidCallback onMenuPressed; // для открытия левого Drawer
  final VoidCallback onPromtsPressed; // callback для кнопки Promts

  const WidgetAppBar({
    super.key,
    required this.onMenuPressed,
    required this.onPromtsPressed,
  });

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      automaticallyImplyLeading: false,
      title: Row(
        children: [
          // Кнопка открытия NavigationDrawer (иконка "3 полоски")
          IconButton(
            icon: const Icon(Icons.menu),
            onPressed: onMenuPressed,
          ),
          // Кнопка "Promts"
          TextButton(
            onPressed: onPromtsPressed, // вызываем переданный callback
            child: const Text(
              "Promts",
              style: TextStyle(fontSize: 20, color: Colors.black),
            ),
          ),
          // Центр AppBar (название чата)
          const Expanded(
            child: Text(
              "Обычный чат-бот",
              textAlign: TextAlign.center,
              style: TextStyle(fontWeight: FontWeight.w600),
            ),
          ),
          // Кнопка настроек пользователя (иконка человечка)
          IconButton(
            icon: const Icon(Icons.person),
            onPressed: () {
              showDialog(
                context: context,
                builder: (_) => WidgetUserSettings(
                  email: "BoberKurwa@rambler.ru",
                  userId: 167491164,
                  balance: 191.61,
                  memoryEnabled: true,
                  aiCanUpdateMemory: true,
                  memory: "Имя пользователя Максим, из Перми (и т.д.)",
                  selectedModel: "DeepSeek V3",
                  availableModels: const [
                    "DeepSeek V3",
                    "DeepSeek R1",
                    "YandexGPT 5 Pro",
                    "YandexGPT 5 Lite",
                    "ChatGPT 4o mini",
                    "ChatGPT 4o",
                    "ChatGPT o1",
                    "Qwen-Max",
                    "Qwen-Turbo",
                  ],
                  onSave: (updatedData) {
                    print("Новые настройки: $updatedData");
                  },
                ),
              );
            },
          ),
          // Кнопка открытия виджета чат-ботов
          IconButton(
            icon: const Icon(Icons.android),
            onPressed: () {
              showAdaptiveDialog(
                context: context,
                builder: (BuildContext dialogContext) {
                  return const Dialog(
                    child: SizedBox(
                      width: 600,
                      child: WidgetChatBots(),
                    ),
                  );
                },
              );
            },
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'widget_app_bar.dart';
import 'package:promts_application_1/features/chat/view/widgets/widget_chats.dart';
import 'package:promts_application_1/features/neuro/view/widget_neuro_button.dart';
import 'package:promts_application_1/features/chat/view/widgets/widget_chat_page.dart';

class WidgetMainScreen extends StatefulWidget {
  const WidgetMainScreen({super.key});

  @override
  State<WidgetMainScreen> createState() => _WidgetMainScreenState();
}

class _WidgetMainScreenState extends State<WidgetMainScreen> {
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();

  // Флаг, указывающий, нужно ли показывать страницу чата
  bool _showChatPage = false;

  // Поле ввода на главном экране (если ещё нужно)
  final TextEditingController _messageController = TextEditingController();

  @override
  void dispose() {
    _messageController.dispose();
    super.dispose();
  }

  // Открываем страницу чата
  void _openChatWithMessage() {
    final text = _messageController.text.trim();
    if (text.isEmpty) return;
    print("Отправлено сообщение на главном экране: $text");
    _messageController.clear();
    setState(() {
      _showChatPage = true;
    });
  }

  // Открываем страницу чата (при выборе чата)
  void _openChat(String chatName) {
    print("Открываем чат: $chatName");
    _messageController.clear();
    setState(() {
      _showChatPage = true;
    });
  }

  // Функция для перехода с чата на обычный экран
  void _closeChat() {
    setState(() {
      _showChatPage = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,

      // Левый Drawer
      drawer: SizedBox(
        width: 350,
        child: Drawer(
          child: WidgetChats(
            onChatSelected: _openChat,
          ),
        ),
      ),

      // AppBar
      appBar: WidgetAppBar(
        onMenuPressed: () {
          _scaffoldKey.currentState?.openDrawer();
        },
        onPromtsPressed: () {
          _closeChat();
        },
      ),

      /// Экран чата
      body: _showChatPage
          ? const Column(
              children: [
                // Кнопка выбора нейросети + кнопка настроек
                Padding(
                  padding: EdgeInsets.all(16.0),
                  child: WidgetNeuroButton(),
                ),
                // Сам экран чата
                Expanded(child: WidgetChatPage()),
              ],
            )
          : _buildMainContent(),
    );
  }
  /// Обычный экран
  Widget _buildMainContent() {
    return SafeArea(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Кнопка выбора нейросети + кнопка настроек
          const Padding(
            padding: EdgeInsets.all(16.0),
            child: WidgetNeuroButton(),
          ),
          // Основная часть экрана
          Expanded(
            child: Center(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Текст "абвгд"
                    const Text(
                      "абвгд",
                      style:
                          TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    // Строка ввода (ограничение 900 px) + кнопка отправки
                    ConstrainedBox(
                      constraints: const BoxConstraints(maxWidth: 900),
                      child: Row(
                        children: [
                          Expanded(
                            child: TextField(
                              controller: _messageController,
                              decoration: const InputDecoration(
                                labelText: "Введите сообщение",
                                border: OutlineInputBorder(),
                              ),
                              keyboardType: TextInputType.multiline,
                              minLines: 1,
                              maxLines: 8,
                            ),
                          ),
                          const SizedBox(width: 8),
                          IconButton(
                            icon: const Icon(Icons.send),
                            onPressed: _openChatWithMessage,
                            tooltip: "Отправить",
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';

class WidgetSnackBar {
  /// Показывает SnackBar с текстом ошибки [errorMessage].
  /// Цвет фона — красный, длительность — 3 секунды.
  static void showError(BuildContext context, String errorMessage) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(errorMessage),
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}
class NeuralNetworkDTO {
  final int id;
  final String name;
  final String desc;

  NeuralNetworkDTO({
    required this.id,
    required this.name,
    required this.desc,
  });

  factory NeuralNetworkDTO.fromJson(Map<String, dynamic> json) {
    return NeuralNetworkDTO(
      id: json['id'] as int,
      name: json['name'] as String? ?? 'Unnamed model',
      desc: json['desc'] as String? ?? '',
    );
  }
}
import 'package:flutter/material.dart';
import 'package:promts_application_1/features/chat/view/widgets/widget_chat_create_settings.dart';
/// Виджет выбора нейросети (DropdownButton) + кнопка настроек чата.
/// Максимальная ширина выпадающего списка ограничена 375 px.
class WidgetNeuroButton extends StatefulWidget {
  const WidgetNeuroButton({super.key});

  @override
  State<WidgetNeuroButton> createState() => _WidgetNeuroButtonState();
}

class _WidgetNeuroButtonState extends State<WidgetNeuroButton> {
  // По умолчанию выбранная нейросеть
  String _selectedNetwork = "DeepSeek V3";

  // Список доступных нейросетей с описаниями
  final List<Map<String, String>> _networks = [
    {
      'name': 'DeepSeek V3',
      'desc': 'Мощная модель для генерации текста.',
    },
    {
      'name': 'DeepSeek R1',
      'desc': 'Улучшенная модель DeepSeek.',
    },
    {
      'name': 'YandexGPT 5 pro',
      'desc': 'Самая продвинутая русская модель.',
    },
    {
      'name': 'YandexGPT 5 Lite',
      'desc': 'Упрощённая версия YandexGPT 5.',
    },
    {
      'name': 'ChatGPT 4o mini',
      'desc': 'Лёгкая версия ChatGPT 4o.',
    },
    {
      'name': 'ChatGPT 4o',
      'desc': 'Полноценная версия ChatGPT 4o.',
    },
    {
      'name': 'ChatGPT o1',
      'desc': 'Экспериментальная модель ChatGPT.',
    },
    {
      'name': 'Qwen-Max',
      'desc': 'Расширенная версия Qwen.',
    },
    {
      'name': 'Qwen-Turbo',
      'desc': 'Ускоренная версия Qwen.',
    },
  ];

  // Обрабатываем выбор новой нейросети
  void _onNetworkChanged(String newNetwork) {
    setState(() {
      _selectedNetwork = newNetwork;
    });
  }

  // Открываем окно настроек по центру экрана (пример с AlertDialog)
void _openSettingsDialog() {
  showDialog(
    context: context,
    builder: (_) => WidgetChatCreateSettings(
      chatId: 54719041,
      temperature: 1.0,
      contextChat: "Описание...",
      useMemory: true,
      updateMemory: false,
      onSave: (updatedData) {
        // Здесь обработка новых данных чата
        // updatedData['temperature'], updatedData['contextChat'], и т.д.
        print("Новые настройки чата: $updatedData");
        // TODO: отправить изменения на бэкенд
      },
    ),
  );
}


  @override
  Widget build(BuildContext context) {
    // Проверяем, является ли устройство "очень узким" (для уменьшения шрифта описания, при желании)
    final isSmallWidth = MediaQuery.of(context).size.width < 350;

    return Row(
      children: [
        // Flexible, чтобы не «выталкивать» другие элементы
        Flexible(
          // ConstrainedBox ограничивает ширину в 375 пикселей максимум
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 375),
            child: DropdownButtonHideUnderline(
              child: DropdownButton<String>(
                isExpanded: true, // Растягиваем до доступной ширины (но не более 375)
                value: _selectedNetwork,
                items: _networks.map((net) {
                  return DropdownMenuItem<String>(
                    value: net['name'],
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        // Название нейросети
                        Text(
                          net['name'] ?? '',
                          style: const TextStyle(fontWeight: FontWeight.bold),
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        // Описание нейросети (ограничиваем 2 строками)
                        if (net['desc'] != null && net['desc']!.isNotEmpty)
                          Text(
                            net['desc']!,
                            style: TextStyle(
                              fontSize: isSmallWidth ? 10 : 12,
                              color: Colors.grey,
                            ),
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                          ),
                      ],
                    ),
                  );
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    _onNetworkChanged(value);
                  }
                },
              ),
            ),
          ),
        ),
        const SizedBox(width: 10),
        // Кнопка настроек (иконка шестерёнка)
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: _openSettingsDialog,
        ),
      ],
    );
  }
}

class UserDTO {
  final int id;
  final String email;
  final String role;
  final double money;
  final String memory;
  final bool memoryEnabled;
  final bool aiCanUpdateMemory;
  final int standardModelUriId;

  UserDTO({
    required this.id,
    required this.email,
    required this.role,
    required this.money,
    required this.memory,
    required this.memoryEnabled,
    required this.aiCanUpdateMemory,
    required this.standardModelUriId,
  });

  factory UserDTO.fromJson(Map<String, dynamic> json) {
    return UserDTO(
      id: json['id'] as int,
      email: json['email'] as String,
      role: json['role'] as String,
      money: (json['money'] as num).toDouble(),
      memory: json['memory'] as String? ?? "",
      memoryEnabled: json['memoryEnabled'] as bool? ?? false,
      aiCanUpdateMemory: json['aiCanUpdateMemory'] as bool? ?? false,
      standardModelUriId: json['standardModelUriId'] as int? ?? 1,
    );
  }
}
// file: lib/data/models/user_response_dto.dart
// Объединяет все поля из удачного ответа для /user/registration и /user/login
import '../../../chat/data/models/chat_short_dto.dart';
import '../../../user/data/models/user_dto.dart';
import '../../../neuro/data/models/neuro_dto.dart';

class UserResponseDTO {
  final UserDTO user;
  final List<ChatShortDTO> chats;
  final List<NeuralNetworkDTO> neuralNetworks;

  UserResponseDTO({
    required this.user,
    required this.chats,
    required this.neuralNetworks,
  });

  factory UserResponseDTO.fromJson(Map<String, dynamic> json) {
    // Пример структуры успешного ответа:
    // {
    //   "user": {...},
    //   "chats": [...],
    //   "neuralNetworks": [...]
    // }
    final user = UserDTO.fromJson(json['user'] as Map<String, dynamic>);
    final chatsJson = json['chats'] as List<dynamic>? ?? [];
    final networksJson = json['neuralNetworks'] as List<dynamic>? ?? [];

    final chats = chatsJson
        .map((chat) => ChatShortDTO.fromJson(chat as Map<String, dynamic>))
        .toList();

    final neuralNetworks = networksJson
        .map((net) => NeuralNetworkDTO.fromJson(net as Map<String, dynamic>))
        .toList();

    return UserResponseDTO(
      user: user,
      chats: chats,
      neuralNetworks: neuralNetworks,
    );
  }
}
import 'package:flutter/material.dart';

class WidgetUserSettings extends StatefulWidget {
  final String email;              
  final int userId;                
  final double balance;            
  final bool memoryEnabled;        
  final bool aiCanUpdateMemory;    
  final String memory;             
  final String selectedModel;      
  final List<String> availableModels; 
  final ValueChanged<Map<String, dynamic>> onSave;

  const WidgetUserSettings({
    super.key,
    required this.email,
    required this.userId,
    required this.balance,
    required this.memoryEnabled,
    required this.aiCanUpdateMemory,
    required this.memory,
    required this.selectedModel,
    required this.availableModels,
    required this.onSave,
  });

  @override
  State<WidgetUserSettings> createState() => _WidgetUserSettingsState();
}

class _WidgetUserSettingsState extends State<WidgetUserSettings> {
  late TextEditingController _memoryController;
  late bool _memoryEnabled;
  late bool _aiCanUpdateMemory;
  late String _selectedModel;
  late double _balance;

  @override
  void initState() {
    super.initState();
    _memoryController = TextEditingController(text: widget.memory);
    _memoryEnabled = widget.memoryEnabled;
    _aiCanUpdateMemory = widget.aiCanUpdateMemory;
    _selectedModel = widget.selectedModel;
    _balance = widget.balance;
  }

  @override
  void dispose() {
    _memoryController.dispose();
    super.dispose();
  }

  void _handleSave() {
    final updatedData = {
      'memory': _memoryController.text,
      'memoryEnabled': _memoryEnabled,
      'aiCanUpdateMemory': _aiCanUpdateMemory,
      'selectedModel': _selectedModel,
      'balance': _balance,
    };
    widget.onSave(updatedData);
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text("Настройки пользователя"),
      content: SizedBox(
        width: 400, 
        height: 400,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 1) Почта
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Эл. почта:"),
                Flexible(child: Text(widget.email)),
              ],
            ),
            const SizedBox(height: 8),

            // 2) ID
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("ID:"),
                Text(widget.userId.toString()),
              ],
            ),
            const SizedBox(height: 8),

            // 3) Баланс + кнопка "+"
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Баланс:"),
                Row(
                  children: [
                    Text("${_balance.toStringAsFixed(2)} руб."),
                    IconButton(
                      icon: const Icon(Icons.add),
                      onPressed: () {
                        setState(() {
                          _balance += 10.0;
                        });
                      },
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 8),

            // 4) Использовать ли память?
            Row(
              children: [
                const Expanded(child: Text("Использовать ли память в чатах?")),
                Switch(
                  value: _memoryEnabled,
                  onChanged: (val) {
                    setState(() {
                      _memoryEnabled = val;
                    });
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // 5) Могут ли чаты изменять память?
            Row(
              children: [
                const Expanded(child: Text("Могут ли чаты изменять память пользователя?")),
                Switch(
                  value: _aiCanUpdateMemory,
                  onChanged: (val) {
                    setState(() {
                      _aiCanUpdateMemory = val;
                    });
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // 6) Модель по умолчанию (Dropdown)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text("Модель чата:"),
                DropdownButton<String>(
                  value: _selectedModel,
                  items: widget.availableModels.map((model) {
                    return DropdownMenuItem<String>(
                      value: model,
                      child: Text(model),
                    );
                  }).toList(),
                  onChanged: (val) {
                    if (val != null) {
                      setState(() {
                        _selectedModel = val;
                      });
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 8),

            // 7) Поле "Память" - чтобы окно не растягивалось, используем Expanded + внутренний скролл
            Expanded(
            child: TextField(
              controller: _memoryController,
              decoration: const InputDecoration(
                labelText: "Память пользователя",
                border: OutlineInputBorder(),
              ),
              keyboardType: TextInputType.multiline,
              minLines: 3,
              maxLines: 5,
            ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text("Отмена"),
        ),
        ElevatedButton(
          onPressed: _handleSave,
          child: const Text("Сохранить"),
        ),
      ],
    );
  }
}
